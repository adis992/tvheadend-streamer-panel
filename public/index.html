<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TVHeadend Streamer - Home</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            display: flex;
        }
        
        /* Sidebar */
        .sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.3);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            color: white;
            padding: 20px 0;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
        }
        
        .sidebar-brand {
            text-align: center;
            padding: 0 20px 30px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .sidebar-brand h4 {
            margin: 0;
            font-weight: bold;
        }
        
        .nav-item {
            margin: 5px 15px;
        }
        
        .nav-link {
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            padding: 12px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .nav-link:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .nav-link.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }
        
        .nav-link i {
            margin-right: 10px;
            width: 20px;
            text-align: center;
        }
        
        /* Main content */
        .main-content {
            margin-left: 250px;
            flex: 1;
            padding: 20px;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.1);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            color: white;
            text-align: center;
        }
        
        .gpu-status {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }
        
        .gpu-badge {
            padding: 8px 15px;
            border-radius: 25px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.8em;
        }
        
        .gpu-available { background: #28a745; color: white; }
        .gpu-unavailable { background: #dc3545; color: white; }
        
        .system-stats {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.8em;
            opacity: 0.8;
            text-transform: uppercase;
        }
        
        .stat-icon {
            margin-bottom: 8px;
            font-size: 1.2em;
        }
        
        .gpu-detailed {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .gpu-metric {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
        }
        
        .controls-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        /* Horizontal Controls Panel */
        .controls-panel-horizontal {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        /* GPU Fan Control Styles */
        .gpu-fan-control {
            background: rgba(0, 123, 255, 0.05);
            border: 1px solid rgba(0, 123, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .fan-control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .fan-speed-display {
            font-weight: bold;
            color: #007bff;
        }
        
        .fan-slider {
            flex: 1;
            margin: 0 10px;
        }
        
        .fan-mode-toggle {
            min-width: 80px;
        }
        
        .stats-panel-compact {
            background: rgba(0, 123, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(0, 123, 255, 0.2);
        }
         .search-input-width {
            width: 300px;
        }

        .channels-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .channels-container-full-width {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: none;
            width: 100%;
        }
        
        .channels-container-wide {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            width: 200%;
            max-width: none;
            margin-left: -50%;
        }
        
        /* Grid layout for channels */
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        /* Responsive grid for smaller screens */
        @media (max-width: 768px) {
            .channels-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
        
        @media (max-width: 576px) {
            .channels-grid {
                gap: 10px;
            }
        }
        
        .channel-card {
            border: none;
            border-radius: 12px;
            transition: all 0.3s ease;
            overflow: hidden;
            height: fit-content;
        }
        
        .channel-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }
        
        .channel-active {
            border-left: 5px solid #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        }
        
        .channel-transcoding {
            border-left: 5px solid #ffc107;
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        }
        
        .btn-sm {
            font-size: 0.8rem;
            padding: 4px 8px;
        }
        
        .badge {
            font-size: 0.7rem;
        }
        
        .status-idle { background: #6c757d; }
        .status-transcoding { background: #ffc107; }
        .status-passthrough { background: #17a2b8; }
        .status-streaming { background: #28a745; }
        .status-error { background: #dc3545; }
        
        /* Grid Layout Styles */
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 20px;
            padding: 0;
        }
        
        .channel-card {
            display: flex;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            margin-bottom: 0; /* Remove margin for grid */
        }
        
        .channel-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        /* Mouse Scroll Zoom */
        html {
            transition: all 0.3s ease;
        }
        
        html.zoom-80 {
            zoom: 0.8;
            -webkit-transform: scale(0.8);
            -webkit-transform-origin: 0 0;
            -moz-transform: scale(0.8);
            -moz-transform-origin: 0 0;
            -o-transform: scale(0.8);
            -o-transform-origin: 0 0;
            transform: scale(0.8);
            transform-origin: 0 0;
        }
        
        html.zoom-90 {
            zoom: 0.9;
            -webkit-transform: scale(0.9);
            -webkit-transform-origin: 0 0;
            -moz-transform: scale(0.9);
            -moz-transform-origin: 0 0;
            -o-transform: scale(0.9);
            -o-transform-origin: 0 0;
            transform: scale(0.9);
            transform-origin: 0 0;
        }
        
        html.zoom-100 {
            zoom: 1;
            -webkit-transform: scale(1);
            -webkit-transform-origin: 0 0;
            -moz-transform: scale(1);
            -moz-transform-origin: 0 0;
            -o-transform: scale(1);
            -o-transform-origin: 0 0;
            transform: scale(1);
            transform-origin: 0 0;
        }
        
        /* Responsive Grid Adjustments */
        @media (max-width: 768px) {
            .channels-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .channel-card {
                flex-direction: column;
                align-items: center;
                text-align: center;
            }
            
            .channel-controls {
                min-width: auto;
                width: 100%;
                margin-top: 15px;
            }
        }
        
        @media (min-width: 1200px) {
            .channels-grid {
                grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
            }
        }
        
        @media (min-width: 1600px) {
            .channels-grid {
                grid-template-columns: repeat(auto-fill, minmax(550px, 1fr));
            }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }
            
            .main-content {
                margin-left: 0;
            }
        }
        
        .controls-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .channels-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .channel-card {
            border: none;
            border-radius: 12px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .channel-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }
        
        .channel-active {
            border-left: 5px solid #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        }
        
        .channel-transcoding {
            border-left: 5px solid #ffc107;
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        }
        
        .channel-logo {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            margin-right: 15px;
        }
        
        .channel-info {
            flex-grow: 1;
        }
        
        .channel-name {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        .channel-group {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }
        
        .channel-controls {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            flex-wrap: wrap;
            flex-direction: column;
            min-width: 200px;
        }
        
        .channel-profile-select,
        .channel-gpu-select {
            width: 100%;
        }
        
        .form-label-sm {
            font-size: 0.75rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 2px;
        }
        
        .active-stream-info {
            background: rgba(40, 167, 69, 0.1);
            padding: 5px;
            border-radius: 3px;
            border-left: 3px solid #28a745;
            width: 100%;
        }
        
        .udp-info {
            background: rgba(0, 0, 0, 0.05);
            padding: 8px;
            border-radius: 5px;
            margin-top: 5px;
            border-left: 3px solid #198754;
        }
        
        .udp-info button {
            padding: 0 3px;
            color: #0d6efd;
        }
        
        .udp-info small {
            word-break: break-all;
        }
        
        .status-badge {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .status-active { background: #28a745; color: white; }
        .status-inactive { background: #6c757d; color: white; }
        .status-transcoding { background: #ffc107; color: #333; }
        .status-passthrough { background: #17a2b8; color: white; }
        
        .btn-sm {
            padding: 5px 12px;
            font-size: 0.85em;
        }
        
        .progress-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 300px;
            z-index: 1000;
        }
        
        .progress-item {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .stats-panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            color: white;
            text-align: center;
        }
        
        .stat-item {
            margin: 10px 0;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            display: block;
        }
        
        .channel-url {
            font-family: monospace;
            font-size: 0.8em;
            color: #666;
            word-break: break-all;
            margin-top: 5px;
        }
        
        .output-link {
            font-size: 0.8em;
            margin-top: 3px;
            padding: 2px 0;
        }
        
        .output-link a {
            font-family: monospace;
            color: inherit;
        }
        
        .output-link .btn-link {
            font-size: 0.7em;
            margin-left: 5px;
        }
        
        .bandwidth-info {
            font-size: 0.8em;
            color: #28a745;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .bandwidth-info i {
            margin-right: 5px;
        }
        
        .vlc-button {
            background: linear-gradient(135deg, #ff8c00 0%, #ff6347 100%);
            border: none;
            color: white;
        }
        
        .vlc-button:hover {
            background: linear-gradient(135deg, #ff6347 0%, #ff4500 100%);
            color: white;
        }
        
        .vlc-not-installed {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        @media (max-width: 768px) {
            .channel-controls {
                width: 100%;
                margin-top: 10px;
            }
            
            .gpu-status {
                flex-direction: column;
                align-items: center;
            }
        }
        
        .udp-info {
            background: rgba(0, 0, 0, 0.05);
            padding: 8px;
            border-radius: 5px;
            margin-top: 5px;
            border-left: 3px solid #198754;
        }
        
        .udp-info button {
            padding: 0 3px;
            color: #0d6efd;
        }
        
        .udp-info small {
            word-break: break-all;
        }
        
        /* GPU Monitoring Styles */
        .gpu-monitoring {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .gpu-monitoring.hidden {
            display: none !important;
        }
        
        .gpu-load-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            padding: 15px;
            min-width: 220px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .gpu-load-card.header-card {
            min-width: 180px;
            padding: 10px;
            font-size: 0.9em;
        }
        
        .gpu-load-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .gpu-load-header i {
            margin-right: 8px;
            font-size: 1.2em;
        }
        
        .gpu-load-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .gpu-load-value.header-value {
            font-size: 1.5em;
            margin: 5px 0;
        }
        
        .gpu-load-details {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .gpu-load-bar {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            height: 8px;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .gpu-load-progress {
            background: #28a745;
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        .gpu-load-progress.high {
            background: #dc3545;
        }
        
        .gpu-load-progress.medium {
            background: #ffc107;
        }
        
        /* Table styling for double width and better appearance */
        #channels-table {
            width: 200% !important;
            min-width: 1200px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        #channels-table thead th {
            background: linear-gradient(135deg, #343a40, #495057);
            color: white;
            font-weight: 600;
            font-size: 13px;
            padding: 12px 8px;
            vertical-align: middle;
            border: none;
            text-align: center;
        }
        
        #channels-table th:nth-child(1) { width: 20%; }
        #channels-table th:nth-child(2) { width: 12%; }
        #channels-table th:nth-child(3) { width: 10%; }
        #channels-table th:nth-child(4) { width: 12%; }
        #channels-table th:nth-child(5) { width: 12%; }
        #channels-table th:nth-child(6) { width: 10%; }
        #channels-table th:nth-child(7) { width: 20%; }
        #channels-table th:nth-child(8) { width: 14%; }
        
        #channels-table td {
            font-size: 12px;
            padding: 10px 8px;
            vertical-align: middle;
            border-bottom: 1px solid #dee2e6;
        }
        
        #channels-table .form-select {
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        #channels-table .btn {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .table-responsive {
            overflow-x: auto;
            border-radius: 8px;
        }
        
        /* GPU Stats Cards Styling */
        .gpu-info-card {
            border: none;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }
        
        .gpu-info-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
        }
        
        .gpu-info-card .card-body {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 12px;
        }
        
        /* Status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .status-active {
            background: #d1f2eb;
            color: #27ae60;
        }
        
        .status-transcoding {
            background: #fef9e7;
            color: #f39c12;
        }
        
        .status-passthrough {
            background: #ebf3fd;
            color: #3498db;
        }
        
        .status-inactive {
            background: #f8f9fa;
            color: #95a5a6;
        }
        
        /* Better stat boxes */
        .stat-box {
            background: linear-gradient(135deg, #ffffff, #f8f9fa) !important;
            border: 1px solid #e3e6f0;
            transition: all 0.3s ease;
        }
        
        .stat-box:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1) !important;
        }
        
        /* GPU Info Cards */
        .gpu-info-card {
            border: 1px solid #dee2e6;
            transition: all 0.3s ease;
        }
        
        .gpu-info-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .gpu-info-card .card-body {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }
        
        .gpu-info-card .card-title {
            color: #495057;
            font-weight: bold;
        }
        
        /* Download options header styling */
        .download-options-header {
            margin-left: 20px;
        }
        
        .download-options-header .btn {
            margin: 0 2px;
            transition: all 0.3s ease;
        }
        
        .download-options-header .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <div class="sidebar">
        <div class="sidebar-brand">
            <h4><i class="fas fa-broadcast-tower"></i> TVH Streamer</h4>
            <small>GPU Transcoder Panel</small>
        </div>
        
        <nav class="nav flex-column">
            <div class="nav-item">
                <a class="nav-link active" href="index.html">
                    <i class="fas fa-home"></i> Home
                </a>
            </div>
            <div class="nav-item">
                <a class="nav-link" href="settings.html">
                    <i class="fas fa-cog"></i> Settings
                </a>
            </div>
            <div class="nav-item">
                <a class="nav-link" href="installation.html">
                    <i class="fas fa-download"></i> Installation
                </a>
            </div>
            <div class="nav-item">
                <a class="nav-link" href="kernel.html">
                    <i class="fas fa-microchip"></i> Kernel
                </a>
            </div>
            <div class="nav-item">
                <a class="nav-link" href="about.html">
                    <i class="fas fa-info-circle"></i> About
                </a>
            </div>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Header -->
        <div class="header">
            <div class="d-flex justify-content-between align-items-center">
                <div class="text-center flex-grow-1">
                    <h1><i class="fas fa-broadcast-tower"></i> TVHeadend Streamer</h1>
                    <p class="mb-0">GPU Accelerated Transcoding Platform</p>
                </div>
                
                <!-- Download Options in Header -->
                <div class="download-options-header">
                    <div class="d-flex gap-2">
                        <button class="btn btn-success btn-sm" id="updateSystem" title="Update System">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                        <button class="btn btn-outline-primary btn-sm" id="downloadChannelList" title="Download Channel List">
                            <i class="fas fa-download"></i>
                        </button>
                        <button class="btn btn-outline-primary btn-sm" id="downloadActiveStreams" title="Download Active Streams">
                            <i class="fas fa-download"></i>
                        </button>
                        <button class="btn btn-outline-primary btn-sm" id="exportActiveLinks" title="Export XTREAM-UI/XUI Links">
                            <i class="fas fa-file-export"></i>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- GPU Load Information in Header -->
            <div class="gpu-load-header mt-3" id="gpu-load-header">
                <div class="row justify-content-center" id="gpu-load-cards-header">
                    <!-- GPU load cards will be populated here -->
                </div>
            </div>
            
            <div class="gpu-status">
                <div id="nvidia-status" class="gpu-badge gpu-unavailable">
                    <i class="fas fa-microchip"></i> NVIDIA: Checking...
                </div>
                <div id="amd-status" class="gpu-badge gpu-unavailable">
                    <i class="fas fa-microchip"></i> AMD: Checking...
                </div>
            </div>
        </div>
        
        <!-- GPU Statistics Row -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">
                            <i class="fas fa-microchip"></i> GPU Status i Performanse
                            <button class="btn btn-sm btn-outline-primary float-end" onclick="refreshGPUStats()" title="Osveži GPU statistike">
                                <i class="fas fa-sync"></i>
                            </button>
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="row" id="gpu-stats-container">
                            <div class="col-12 text-center text-muted">
                                <i class="fas fa-spinner fa-spin"></i> Učitavam GPU statistike...
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Statistics Row Above Table -->
        <div class="row mb-4 justify-content-center text-center">
            <div class="col-md-3 mb-2">
                <div class="stat-box bg-light rounded shadow-sm py-3">
                    <div class="fw-bold">Kanala</div>
                    <div id="total-channels" class="fs-4 text-primary">42</div>
                </div>
            </div>
            <div class="col-md-3 mb-2">
                <div class="stat-box bg-light rounded shadow-sm py-3">
                    <div class="fw-bold">Aktivni stream-ovi</div>
                    <div id="active-streams" class="fs-4 text-success">1</div>
                </div>
            </div>
            <div class="col-md-3 mb-2">
                <div class="stat-box bg-light rounded shadow-sm py-3">
                    <div class="fw-bold">Ukupna potrošnja</div>
                    <div id="bandwidth-usage" class="fs-4 text-info">8.0 MB/s</div>
                </div>
            </div>
        </div>
        
        <!-- Controls Row -->
        <div class="row mb-3">
            <div class="col-md-2">
                <button id="start-all-btn" class="btn btn-success w-100">
                    <i class="fas fa-play"></i> Pokreni SVE
                </button>
            </div>
            <div class="col-md-2">
                <button id="stop-all-btn" class="btn btn-danger w-100">
                    <i class="fas fa-stop"></i> Zaustavi SVE
                </button>
            </div>
            <div class="col-md-8">
                <!-- Spacer -->
            </div>
        </div>

        <!-- Channels List - Full Width Table -->
        <div class="row">
            <div class="col-12">
                <div class="channels-container-full-width">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4><i class="fas fa-list"></i> Kanali</h4>
                        <div class="d-flex gap-2">
                            <button class="btn btn-sm btn-outline-primary" onclick="manualRefreshChannels()" title="Osveži prikaz kanala">
                                <i class="fas fa-sync"></i>
                            </button>
                            <div class="input-group search-input-width">
                                <span class="input-group-text"><i class="fas fa-search"></i></span>
                                <input type="text" id="search-input" class="form-control" placeholder="Pretraži kanale...">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Normal Table Structure -->
                    <div class="table-responsive">
                        <table class="table table-striped table-hover" id="channels-table">
                            <thead class="table-dark">
                                <tr>
                                    <th>Kanal</th>
                                    <th>Grupa</th>
                                    <th>Status</th>
                                    <th>Profil</th>
                                    <th>GPU</th>
                                    <th>Propusnost</th>
                                    <th>Stream URL</th>
                                    <th>Kontrole</th>
                                </tr>
                            </thead>
                            <tbody id="channels-list">
                                <tr>
                                    <td colspan="8" class="text-center py-5">
                                        <i class="fas fa-spinner fa-spin fa-3x text-primary"></i>
                                        <p class="mt-3">Učitavam kanale...</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- GPU Statistics Row - Above Table -->
        <div class="row mb-4" id="gpu-stats-container">
            <!-- GPU stats cards will be populated here by JavaScript -->
        </div>
    </div>
    
    <!-- Progress notifications -->
    <div id="progress-container" class="progress-container"></div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>
    
    <script>
        // Initialize Socket.IO
        const socket = io();
        
        // Debug Socket.IO connection
        socket.on('connect', () => {
            console.log('Socket.IO connected to server');
        });
        
        socket.on('disconnect', () => {
            console.log('Socket.IO disconnected from server');
        });
        
        // Global variables
        let channels = [];
        let gpuInfo = { nvidia: false, amd: false };
        let availableGPUs = [];
        let activeStreams = new Set();
        let vlcInstalled = false;
        let availableProfiles = {};
        let autoRefreshEnabled = true;
        let autoRefreshInterval = null;
        let serverConfig = null;
        
        // DOM elements
        const channelsList = document.getElementById('channels-list');
        const refreshBtn = document.getElementById('refresh-btn');
        const searchInput = document.getElementById('search-input');
        const qualitySelect = document.getElementById('quality-select');
        const gpuSelect = document.getElementById('gpu-select');
        const totalChannelsSpan = document.getElementById('total-channels');
        const activeStreamsSpan = document.getElementById('active-streams');
        const progressContainer = document.getElementById('progress-container');
        const nvidiaStatus = document.getElementById('nvidia-status');
        const amdStatus = document.getElementById('amd-status');
        
        // Socket event listeners
        socket.on('connect', () => {
            console.log('🔥 Connected to server');
            fetchGPUInfo();
            checkVLCInstallation();
        });
        
        socket.on('disconnect', () => {
            console.log('🔥 Disconnected from server');
        });
        
        socket.on('reconnect', () => {
            console.log('🔥 Reconnected to server');
        });
        
        socket.on('channelsUpdated', (channelsData) => {
            // Only update if data actually changed
            const channelsChanged = JSON.stringify(channels) !== JSON.stringify(channelsData);
            if (channelsChanged) {
                console.log('Channels data changed, updating UI');
                
                // Initialize default settings for new channels
                channelsData.forEach(channel => {
                    if (!channel.profile) {
                        channel.profile = 'passthrough';
                    }
                    if (!channel.gpu) {
                        channel.gpu = 'auto';
                    }
                });
                
                channels = channelsData;
                renderChannels();
                updateStats();
            }
        });
        
        socket.on('gpuInfo', (info) => {
            gpuInfo = info;
            updateGPUStatus();
        });
        
        socket.on('gpuInfoUpdated', (info) => {
            gpuInfo = info;
            updateGPUStatus();
        });
        
        socket.on('availableGPUs', (gpus) => {
            availableGPUs = gpus;
            console.log('Available GPUs received:', gpus);
            // Re-render channels to update GPU dropdowns
            renderChannels();
        });
        
        // Dodajemo event listener za GPU statistiku
        socket.on('gpuStats', (stats) => {
            console.log('GPU stats received:', stats);
            if (stats && Array.isArray(stats) && stats.length > 0) {
                updateGPUStatsDisplay(stats);
                // Update first GPU in header stats
                document.getElementById('gpu-usage').textContent = stats[0].usage ? `${stats[0].usage}%` : '--%';
                document.getElementById('gpu-memory').textContent = stats[0].memory ? `${stats[0].memory}%` : '--%';
                document.getElementById('gpu-temp').textContent = stats[0].temp ? `${stats[0].temp}°C` : '--°C';
            } else if (stats) {
                // Single GPU format (backward compatibility)
                document.getElementById('gpu-usage').textContent = stats.usage ? `${stats.usage}%` : '--%';
                document.getElementById('gpu-memory').textContent = stats.memory ? `${stats.memory}%` : '--%';
                document.getElementById('gpu-temp').textContent = stats.temp ? `${stats.temp}°C` : '--°C';
            }
        });
        
        async function checkVLCInstallation() {
            try {
                const response = await fetch('/api/check-vlc');
                const result = await response.json();
                vlcInstalled = result.installed;
            } catch (error) {
                console.error('Error checking VLC installation:', error);
                vlcInstalled = false;
            }
        }
        
        socket.on('streamStarted', (data) => {
            console.log(`🔥 RECEIVED streamStarted event:`, data);
            activeStreams.add(data.channelId);
            
            // Show appropriate notification based on stream type
            const statusMessage = data.passthrough 
                ? `Passthrough stream aktiviran za kanal ${data.channelId}` 
                : `Transkodiranje u toku za kanal ${data.channelId} (${data.profile}, ${data.gpu})`;
            showNotification(statusMessage, 'success');
            
            // Update local channel status immediately for responsive UI
            const channel = channels.find(c => c.id === data.channelId);
            if (channel) {
                channel.isActive = true;
                // For passthrough streams, transcoding should be false
                channel.transcoding = data.passthrough ? false : true;
                channel.passthrough = data.passthrough || false;
                channel.profile = data.profile;
                channel.gpu = data.gpu;
                
                console.log(`🔥 Updated channel ${data.channelId}: active=${channel.isActive}, transcoding=${channel.transcoding}, passthrough=${channel.passthrough}, profile=${data.profile}`);
                
                renderChannels(); // Re-render immediately
            } else {
                console.error(`🔥 Channel not found for ID: ${data.channelId}`);
            }
            updateStats();
        });
        
        socket.on('streamStopped', (data) => {
            activeStreams.delete(data.channelId);
            showNotification(`Stream zaustavljen za kanal ${data.channelId}`, 'info');
            
            // Update local channel status immediately
            const channel = channels.find(c => c.id === data.channelId);
            if (channel) {
                channel.isActive = false;
                channel.transcoding = false;
                channel.passthrough = false;
                channel.bandwidth = 0;
                console.log(`Stopped channel ${data.channelId}: active=${channel.isActive}, transcoding=${channel.transcoding}, passthrough=${channel.passthrough}`);
                renderChannels(); // Re-render immediately
            }
            updateStats();
        });
        
        socket.on('transcodingProgress', (data) => {
            updateProgressNotification(data);
        });
        
        socket.on('transcodingError', (data) => {
            showNotification(`Greška u transkodovanju: ${data.error}`, 'error');
        });
        
        // Functions
        async function fetchGPUInfo() {
            try {
                const response = await fetch('/api/gpu-info');
                const info = await response.json();
                gpuInfo = info;
                updateGPUStatus();
            } catch (error) {
                console.error('Error fetching GPU info:', error);
            }
        }
        
        async function fetchChannels() {
            try {
                const response = await fetch('/api/channels');
                const data = await response.json();
                channels = data;
                console.log('Loaded channels:', channels.length);
                
                // Always render channels after loading
                renderChannels();
                updateStats();
            } catch (error) {
                console.error('Error fetching channels:', error);
            }
        }
        
        async function fetchProfiles() {
            try {
                const response = await fetch('/api/profiles');
                const data = await response.json();
                availableProfiles = data.profiles;
                availableGPUs = data.availableGPUs;
                console.log('Loaded profiles:', availableProfiles);
                console.log('Available GPUs:', availableGPUs);
                
                // Debug output for troubleshooting
                console.log('Profile keys:', Object.keys(availableProfiles));
                console.log('GPU structure:', availableGPUs);
                
                // Re-render channels now that profiles are loaded
                if (channels && channels.length > 0) {
                    renderChannels();
                }
            } catch (error) {
                console.error('Error fetching profiles:', error);
            }
        }
        
        function updateGPUStatus() {
            nvidiaStatus.className = `gpu-badge ${gpuInfo.nvidia ? 'gpu-available' : 'gpu-unavailable'}`;
            nvidiaStatus.innerHTML = `<i class="fas fa-microchip"></i> NVIDIA: ${gpuInfo.nvidia ? 'Dostupna' : 'Nedostupna'}`;
            
            amdStatus.className = `gpu-badge ${gpuInfo.amd ? 'gpu-available' : 'gpu-unavailable'}`;
            amdStatus.innerHTML = `<i class="fas fa-microchip"></i> AMD: ${gpuInfo.amd ? 'Dostupna' : 'Nedostupna'}`;
            
            // Update global GPU select with smart defaults
            updateGlobalGPUSelect();
        }
        
        function updateGlobalGPUSelect() {
            const gpuSelect = document.getElementById('gpu-select');
            if (!gpuSelect) return;
            
            // Clear existing options
            gpuSelect.innerHTML = '';
            
            // Smart default - prefer available GPU
            let defaultValue = 'auto';
            if (gpuInfo.amd) {
                defaultValue = 'amd';
            } else if (gpuInfo.nvidia) {
                defaultValue = 'nvidia';
            }
            
            // Add options
            gpuSelect.innerHTML = `
                <option value="auto" ${defaultValue === 'auto' ? 'selected' : ''}>Automatski</option>
                ${gpuInfo.nvidia ? `<option value="nvidia" ${defaultValue === 'nvidia' ? 'selected' : ''}>NVIDIA</option>` : ''}
                ${gpuInfo.amd ? `<option value="amd" ${defaultValue === 'amd' ? 'selected' : ''}>AMD</option>` : ''}
                <option value="cpu">CPU (Backup)</option>
            `;
        }
        
        // Bandwidth calculation functions
        function formatBandwidth(bps) {
            if (!bps || bps === 0) return '-- Mbps';
            
            const mbps = bps / (1024 * 1024);
            if (mbps < 1) {
                const kbps = bps / 1024;
                return `${kbps.toFixed(1)} Kbps`;
            }
            return `${mbps.toFixed(1)} Mbps`;
        }
        
        function calculateBandwidth(channel, profile) {
            // If passthrough or no profile, return original bandwidth
            if (!profile || profile === 'passthrough') {
                return channel.inputBandwidth || 0;
            }
            
            // Estimate transcoded bandwidth based on profile
            const profileBandwidths = {
                'hevc_gpu': 2000000, // 2 Mbps
                'hevc_cpu': 2000000,
                'h264_gpu': 3000000, // 3 Mbps  
                'h264_cpu': 3000000,
                'low_gpu': 1000000,  // 1 Mbps
                'low_cpu': 1000000
            };
            
            return profileBandwidths[profile] || 2000000; // Default 2 Mbps
        }
        
        // Function to refresh GPU information
        async function refreshGPUInfo() {
            try {
                const refreshBtn = document.getElementById('refresh-gpu-btn');
                const originalText = refreshBtn.innerHTML;
                
                // Show loading state
                refreshBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Osvežavam...';
                refreshBtn.disabled = true;
                
                const response = await fetch('/api/refresh-gpu-info', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    gpuInfo = result.gpuInfo;
                    updateGPUStatus();
                    showNotification('GPU informacije su uspešno osvežene!', 'success');
                    
                    // Update GPU monitoring display
                    await updateGPUMonitoring();
                } else {
                    showNotification(`Greška pri osvežavanju GPU informacija: ${result.error}`, 'error');
                }
                
                // Restore button state
                refreshBtn.innerHTML = originalText;
                refreshBtn.disabled = false;
                
            } catch (error) {
                console.error('Error refreshing GPU info:', error);
                showNotification('Greška pri osvežavanju GPU informacija!', 'error');
                
                // Restore button state
                const refreshBtn = document.getElementById('refresh-gpu-btn');
                refreshBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
                refreshBtn.disabled = false;
            }
        }
        
        // Function to refresh GPU statistics
        async function refreshGPUStats() {
            try {
                const response = await fetch('/api/gpu-stats');
                const gpuStats = await response.json();
                
                if (gpuStats && Array.isArray(gpuStats) && gpuStats.length > 0) {
                    updateGPUStatsDisplay(gpuStats);
                    showNotification('GPU statistike osvežene!', 'success');
                } else {
                    showNotification('Nema dostupnih GPU statistika', 'warning');
                }
            } catch (error) {
                console.error('Error refreshing GPU stats:', error);
                showNotification('Greška pri osvežavanju GPU statistika', 'error');
            }
        }
        
        // Enhanced GPU monitoring
        async function updateGPUMonitoring() {
            try {
                const response = await fetch('/api/gpu-stats');
                const gpuStats = await response.json();
                
                if (gpuStats && Array.isArray(gpuStats) && gpuStats.length > 0) {
                    // Update main GPU stats display
                    updateGPUStatsDisplay(gpuStats);
                    
                    // Update header cards if they exist
                    const gpuLoadCardsHeader = document.getElementById('gpu-load-cards-header');
                    if (gpuLoadCardsHeader) {
                        const headerCards = gpuStats.map((gpu, index) => {
                            const usageClass = gpu.usage > 80 ? 'text-danger' : gpu.usage > 50 ? 'text-warning' : 'text-success';
                            return `
                                <div class="col-auto">
                                    <div class="card gpu-card">
                                        <div class="card-body text-center py-2">
                                            <h6 class="card-title mb-1">${gpu.name || `GPU ${index + 1}`}</h6>
                                            <div class="${usageClass}">
                                                <i class="fas fa-microchip"></i> ${gpu.usage || 0}%
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                        
                        gpuLoadCardsHeader.innerHTML = headerCards;
                    }
                } else {
                    // No GPU stats available
                    const gpuStatsContainer = document.getElementById('gpu-stats-container');
                    if (gpuStatsContainer) {
                        gpuStatsContainer.innerHTML = '<div class="col-12 text-center text-muted">GPU monitoring nedostupan</div>';
                    }
                    
                    const gpuLoadCardsHeader = document.getElementById('gpu-load-cards-header');
                    if (gpuLoadCardsHeader) {
                        gpuLoadCardsHeader.innerHTML = '<div class="col-auto"><small class="text-muted">GPU monitoring nedostupan</small></div>';
                    }
                }
            } catch (error) {
                console.error('Error updating GPU monitoring:', error);
                const gpuStatsContainer = document.getElementById('gpu-stats-container');
                if (gpuStatsContainer) {
                    gpuStatsContainer.innerHTML = '<div class="col-12 text-center text-muted">GPU monitoring greška</div>';
                }
                
                const gpuLoadCardsHeader = document.getElementById('gpu-load-cards-header');
                if (gpuLoadCardsHeader) {
                    gpuLoadCardsHeader.innerHTML = '<div class="col-auto"><small class="text-muted">GPU monitoring greška</small></div>';
                }
            }
        }
        
        async function fetchServerConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                serverConfig = config;
                console.log('Server config loaded:', serverConfig);
                
                // Load initial data now that config is available
                await fetchChannels();
                await fetchProfiles();
                await updateGPUMonitoring();
                
            } catch (error) {
                console.error('Error loading server config:', error);
                // Use default config if API fails
                serverConfig = {
                    streaming: { port: 3001 }
                };
                // Still try to load channels
                await fetchChannels();
                await fetchProfiles();
            }
        }

        // Stream control functions
        async function startStreamWithOptions(channelId) {
            console.log(`🔥 Starting stream for channel ${channelId}`);
            
            const profileSelect = document.getElementById(`profile-${channelId}`);
            const gpuSelect = document.getElementById(`gpu-${channelId}`);
            
            const profile = profileSelect ? profileSelect.value : 'passthrough';
            const gpu = gpuSelect ? gpuSelect.value : 'auto';
            
            console.log(`🔥 Profile: ${profile}, GPU: ${gpu}`);
            
            try {
                const response = await fetch(`/api/start-stream/${channelId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profile, gpu })
                });
                
                const result = await response.json();
                console.log(`🔥 API response:`, result);
                
                if (response.ok) {
                    const statusMessage = profile === 'passthrough' 
                        ? `Passthrough stream aktiviran za kanal ${channelId}` 
                        : `Transkodiranje pokrenuto za kanal ${channelId} (${profile}, ${gpu})`;
                    showNotification(statusMessage, 'success');
                    
                    renderChannels();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error(`🔥 Error starting stream:`, error);
                showNotification(`Greška pokretanja: ${error.message}`, 'error');
            }
        }
        
        async function stopStream(channelId) {
            try {
                const response = await fetch(`/api/stop-stream/${channelId}`, { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    showNotification(`Stream zaustavljen za kanal ${channelId}`, 'info');
                    renderChannels();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showNotification(`Greška zaustavljanja: ${error.message}`, 'error');
            }
        }
        
        async function startUdp(channelId) {
            try {
                const profileSelect = document.getElementById(`profile-${channelId}`);
                const gpuSelect = document.getElementById(`gpu-${channelId}`);
                
                const profile = profileSelect ? profileSelect.value : 'passthrough';
                const gpu = gpuSelect ? gpuSelect.value : 'auto';
                
                const response = await fetch(`/api/start-udp/${channelId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profile, gpu })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showNotification(`UDP stream pokrenut za kanal ${channelId}`, 'success');
                    renderChannels();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showNotification(`Greška pokretanja UDP: ${error.message}`, 'error');
            }
        }
        
        async function stopUdp(channelId) {
            try {
                const response = await fetch(`/api/stop-udp/${channelId}`, { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    showNotification(`UDP stream zaustavljen za kanal ${channelId}`, 'success');
                    renderChannels();
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showNotification(`Greška zaustavljanja UDP: ${error.message}`, 'error');
            }
        }
        
        function openStream(channelId) {
            const channel = channels.find(c => c.id == channelId);
            if (channel && channel.isActive) {
                const streamUrl = getStreamUrl(channel);
                window.open(streamUrl, '_blank');
            }
        }
        
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('URL kopiran u clipboard', 'success');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('URL kopiran u clipboard', 'success');
            });
        }
        
        function copyUdpUrl(url) {
            copyToClipboard(url);
        }
        
        async function openInVlc(url) {
            try {
                const response = await fetch('/api/open-vlc', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: url })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showNotification('VLC pokrennut za URL: ' + url, 'success');
                } else {
                    throw new Error(result.error || 'Failed to open VLC');
                }
            } catch (error) {
                console.error('Error opening VLC:', error);
                showNotification('Greška pokretanja VLC: ' + error.message, 'error');
            }
        }
        
        // Function to save channel settings when dropdown changes
        async function saveChannelSettings(channelId) {
            const profileSelect = document.getElementById(`profile-${channelId}`);
            const gpuSelect = document.getElementById(`gpu-${channelId}`);
            
            const profile = profileSelect ? profileSelect.value : 'passthrough';
            const gpu = gpuSelect ? gpuSelect.value : 'auto';
            
            try {
                const response = await fetch(`/api/save-channel-settings/${channelId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ profile, gpu })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    console.log(`Settings saved for channel ${channelId}: ${profile}, ${gpu}`);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                console.error('Error saving channel settings:', error);
                showNotification(`Greška pri čuvanju postavki: ${error.message}`, 'error');
            }
        }
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `alert alert-${type === 'error' ? 'danger' : type} alert-dismissible fade show`;
            notification.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            // Add to container
            const container = document.getElementById('progress-container');
            if (container) {
                container.appendChild(notification);
                
                // Auto remove after 5 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 5000);
            }
        }
        
        async function refreshPlaylist() {
            try {
                const response = await fetch('/api/refresh-playlist', { method: 'POST' });
                const result = await response.json();
                
                if (result.success) {
                    showNotification('Playlist osvežen uspešno!', 'success');
                    setTimeout(() => {
                        fetchChannels();
                    }, 500);
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showNotification(`Greška: ${error.message}`, 'error');
            }
        }

        // Core function to render channels in the UI - TABLE FORMAT
        function renderChannels() {
            const tableBody = document.getElementById('channels-list');
            if (!tableBody) {
                console.error('Channel list element not found!');
                return;
            }

            // Get search filter
            const searchQuery = searchInput ? searchInput.value.toLowerCase() : '';
            
            // Filter channels
            const filteredChannels = channels.filter(channel => {
                if (!channel.name) return false;
                return channel.name.toLowerCase().includes(searchQuery) || 
                      (channel.group && channel.group.toLowerCase().includes(searchQuery));
            });

            // Generate table rows
            let tableRows = '';
            
            if (filteredChannels.length === 0) {
                tableRows = `
                    <tr>
                        <td colspan="8" class="text-center py-5">
                            <i class="fas fa-search fa-3x text-muted"></i>
                            <p class="mt-3">Nema pronađenih kanala</p>
                        </td>
                    </tr>
                `;
            } else {
                // Generate row for each channel
                filteredChannels.forEach(channel => {
                    // Determine channel status for styling
                    const isActive = activeStreams.has(channel.id) || channel.isActive;
                    const isTranscoding = isActive && channel.transcoding;
                    const isPassthrough = isActive && channel.passthrough;
                    
                    // Calculate bandwidth
                    const profile = channel.profile || 'passthrough';
                    const bandwidth = calculateBandwidth(channel, profile);
                    const formattedBandwidth = formatBandwidth(bandwidth);
                    
                    // Determine status text and class with better styling
                    let statusText = 'Neaktivan';
                    let statusClass = 'status-inactive';
                    
                    if (isActive) {
                        if (isTranscoding) {
                            statusText = 'Transkodiranje';
                            statusClass = 'status-transcoding';
                        } else if (isPassthrough) {
                            statusText = 'Passthrough';
                            statusClass = 'status-passthrough';
                        } else {
                            statusText = 'Aktivan';
                            statusClass = 'status-active';
                        }
                    }
                    
                    // Generate profile options with passthrough as default
                    let profileOptions = `<option value="passthrough" ${!channel.profile || channel.profile === 'passthrough' ? 'selected' : ''}>🔄 Passthrough (Copy)</option>`;
                    
                    if (availableProfiles) {
                        Object.keys(availableProfiles).forEach(profileKey => {
                            const selected = profileKey === channel.profile ? 'selected' : '';
                            const profileName = availableProfiles[profileKey].name;
                            // Add icons for different profile types
                            let icon = '🎬';
                            if (profileKey.includes('hevc')) icon = '📹';
                            if (profileKey.includes('h264')) icon = '🎥';
                            if (profileKey.includes('low')) icon = '📱';
                            
                            profileOptions += `<option value="${profileKey}" ${selected}>${icon} ${profileName}</option>`;
                        });
                    }
                    
                    // Generate GPU options with better names and individual selection
                    let gpuOptions = `<option value="auto" ${!channel.gpu || channel.gpu === 'auto' ? 'selected' : ''}>🤖 Auto (Best Available)</option>`;
                    
                    // Add available GPUs individually - enhanced GPU support
                    if (availableGPUs && availableGPUs.length > 0) {
                        availableGPUs.forEach((gpu, index) => {
                            const gpuId = gpu.id || `gpu-${index}`;
                            const gpuName = gpu.name || `GPU ${index + 1}`;
                            const selected = channel.gpu === gpuId ? 'selected' : '';
                            
                            // Add GPU type icons
                            let icon = '🎮';
                            if (gpuName.toLowerCase().includes('nvidia')) icon = '🟢';
                            if (gpuName.toLowerCase().includes('amd') || gpuName.toLowerCase().includes('radeon')) icon = '🔴';
                            if (gpuName.toLowerCase().includes('intel')) icon = '🔵';
                            
                            gpuOptions += `<option value="${gpuId}" ${selected}>${icon} ${gpuName}</option>`;
                        });
                    } else {
                        // Enhanced fallback for individual GPU cards with better naming
                        if (gpuInfo.nvidia) {
                            // Support for multiple NVIDIA cards
                            for (let i = 0; i < 3; i++) {
                                const gpuId = `nvidia-${i}`;
                                const selected = channel.gpu === gpuId ? 'selected' : '';
                                gpuOptions += `<option value="${gpuId}" ${selected}>🟢 NVIDIA GPU ${i} (RTX/GTX)</option>`;
                            }
                        }
                        
                        if (gpuInfo.amd) {
                            // Support for multiple AMD cards  
                            for (let i = 0; i < 3; i++) {
                                const gpuId = `amd-${i}`;
                                const selected = channel.gpu === gpuId ? 'selected' : '';
                                gpuOptions += `<option value="${gpuId}" ${selected}>🔴 AMD GPU ${i} (RX/Radeon)</option>`;
                            }
                        }
                    }
                    
                    gpuOptions += `<option value="cpu" ${channel.gpu === 'cpu' ? 'selected' : ''}>💻 CPU (Software Encoding)</option>`;
                    
                    // Generate the stream URL for active streams
                    let streamUrl = '';
                    let streamUrlDisplay = '-';
                    if (isActive && serverConfig) {
                        streamUrl = getStreamUrl(channel);
                        streamUrlDisplay = `
                            <div class="input-group input-group-sm">
                                <input type="text" class="form-control form-control-sm" value="${streamUrl}" readonly style="font-size: 11px;">
                                <button class="btn btn-outline-secondary btn-sm" type="button" 
                                        onclick="copyToClipboard('${streamUrl}')" title="Kopiraj URL">
                                    <i class="fas fa-copy"></i>
                                </button>
                                <button class="btn btn-outline-primary btn-sm" type="button" 
                                        onclick="openStream('${channel.id}')" title="Otvori stream">
                                    <i class="fas fa-external-link-alt"></i>
                                </button>
                            </div>
                        `;
                    }

                    // Row class based on channel status
                    const rowClass = isActive 
                        ? isTranscoding 
                            ? 'table-warning' 
                            : 'table-success'
                        : '';
                    
                    tableRows += `
                        <tr class="${rowClass}">
                            <td><strong>${channel.name}</strong></td>
                            <td>${channel.group || '-'}</td>
                            <td><span class="status-indicator ${statusClass}"><i class="fas fa-circle"></i> ${statusText}</span></td>
                            <td>
                                <select class="form-select form-select-sm" 
                                        id="profile-${channel.id}" 
                                        onchange="saveChannelSettings('${channel.id}')"
                                        ${isActive ? 'disabled' : ''}>
                                    ${profileOptions}
                                </select>
                            </td>
                            <td>
                                <select class="form-select form-select-sm" 
                                        id="gpu-${channel.id}" 
                                        onchange="saveChannelSettings('${channel.id}')"
                                        ${isActive ? 'disabled' : ''}>
                                    ${gpuOptions}
                                </select>
                            </td>
                            <td>${isActive ? formattedBandwidth : '-'}</td>
                            <td>${streamUrlDisplay}</td>
                            <td>
                                <div class="btn-group btn-group-sm" role="group">
                                    ${isActive ? `
                                        <button class="btn btn-danger btn-sm" 
                                                onclick="stopStream('${channel.id}')" title="Zaustavi stream">
                                            <i class="fas fa-stop"></i>
                                        </button>
                                    ` : `
                                        <button class="btn btn-success btn-sm" 
                                                onclick="startStreamWithOptions('${channel.id}')" title="Pokreni stream">
                                            <i class="fas fa-play"></i>
                                        </button>
                                    `}
                                    
                                    ${channel.udpUrl && channel.udpUrl.length > 0 ? `
                                        <button class="btn btn-outline-danger btn-sm" 
                                                onclick="stopUdp('${channel.id}')" title="Zaustavi UDP">
                                            <i class="fas fa-broadcast-tower"></i>
                                        </button>
                                    ` : `
                                        <button class="btn btn-outline-primary btn-sm" 
                                                onclick="startUdp('${channel.id}')" title="Pokreni UDP">
                                            <i class="fas fa-broadcast-tower"></i>
                                        </button>
                                    `}
                                </div>
                            </td>
                        </tr>
                    `;
                });
            }
            
            tableBody.innerHTML = tableRows;
        }

        // Function to get the stream URL for a channel
        function getStreamUrl(channel) {
            if (!serverConfig) {
                return '';
            }
            
            const host = window.location.hostname;
            const port = serverConfig.streaming?.port || 3001;
            return `http://${host}:${port}/streams/${channel.id}/playlist.m3u8`;
        }

        // Function to calculate total bandwidth
        function calculateTotalBandwidth() {
            let total = 0;
            channels.forEach(channel => {
                if (activeStreams.has(channel.id) || channel.isActive) {
                    const profile = channel.profile || 'passthrough';
                    total += calculateBandwidth(channel, profile);
                }
            });
            return total;
        }

        // Update statistics row
        function updateStats() {
            if (totalChannelsSpan) {
                totalChannelsSpan.textContent = channels.length;
            }
            
            if (activeStreamsSpan) {
                activeStreamsSpan.textContent = activeStreams.size;
            }
            
            // Update bandwidth
            const bandwidthSpan = document.getElementById('total-bandwidth');
            if (bandwidthSpan) {
                const totalBandwidth = calculateTotalBandwidth();
                bandwidthSpan.textContent = formatBandwidth(totalBandwidth);
            }
        }

        // Handle transcoding progress notifications
        function updateProgressNotification(data) {
            const progressId = `progress-${data.channelId}`;
            let progressItem = document.getElementById(progressId);
            
            if (!progressItem && data.progress < 100) {
                progressItem = document.createElement('div');
                progressItem.id = progressId;
                progressItem.className = 'progress-item';
                progressItem.innerHTML = `
                    <div class="d-flex justify-content-between mb-1">
                        <small>Transkodiranje: Kanal ${data.channelId}</small>
                        <small id="${progressId}-percent">${data.progress}%</small>
                    </div>
                    <div class="progress" style="height: 5px;">
                        <div id="${progressId}-bar" class="progress-bar progress-bar-striped progress-bar-animated" 
                             style="width: ${data.progress}%"></div>
                    </div>
                `;
                
                progressContainer.appendChild(progressItem);
            } else if (progressItem) {
                const progressBar = document.getElementById(`${progressId}-bar`);
                const progressPercent = document.getElementById(`${progressId}-percent`);
                
                if (progressBar) {
                    progressBar.style.width = `${data.progress}%`;
                }
                
                if (progressPercent) {
                    progressPercent.textContent = `${data.progress}%`;
                }
                
                // Remove when complete
                if (data.progress >= 100) {
                    setTimeout(() => {
                        if (progressItem.parentNode) {
                            progressItem.remove();
                        }
                    }, 3000);
                }
            }
        }

        // Manual refresh function
        function manualRefreshChannels() {
            showNotification('Osvežavam kanale...', 'info');
            fetchChannels();
        }

        // Stop all streams
        async function stopAllStreams() {
            try {
                const response = await fetch('/api/stop-all-streams', { method: 'POST' });
                const result = await response.json();
                
                if (response.ok) {
                    showNotification('Svi stream-ovi su zaustavljeni', 'success');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showNotification(`Greška: ${error.message}`, 'error');
            }
        }

        // Function to update GPU stats display above table with enhanced appearance
        function updateGPUStatsDisplay(gpuStats) {
            const gpuStatsContainer = document.getElementById('gpu-stats-container');
            if (!gpuStatsContainer || !gpuStats || !Array.isArray(gpuStats)) return;
            
            let gpuCardsHtml = '';
            
            gpuStats.forEach((gpu, index) => {
                const usageClass = gpu.usage > 80 ? 'text-danger' : gpu.usage > 50 ? 'text-warning' : 'text-success';
                const tempClass = gpu.temp > 80 ? 'text-danger' : gpu.temp > 70 ? 'text-warning' : 'text-success';
                const memClass = gpu.memory > 80 ? 'text-danger' : gpu.memory > 60 ? 'text-warning' : 'text-success';
                
                // Determine GPU brand icon
                let brandIcon = '🎮';
                let brandColor = '#6c757d';
                if (gpu.name && gpu.name.toLowerCase().includes('nvidia')) {
                    brandIcon = '🟢';
                    brandColor = '#76B900';
                } else if (gpu.name && (gpu.name.toLowerCase().includes('amd') || gpu.name.toLowerCase().includes('radeon'))) {
                    brandIcon = '🔴';
                    brandColor = '#ED1C24';
                } else if (gpu.name && gpu.name.toLowerCase().includes('intel')) {
                    brandIcon = '🔵';
                    brandColor = '#0071C5';
                }
                
                gpuCardsHtml += `
                    <div class="col-md-4 mb-3">
                        <div class="card gpu-info-card">
                            <div class="card-body text-center py-3">
                                <h6 class="card-title mb-3" style="color: ${brandColor};">
                                    ${brandIcon} <strong>${gpu.name || `GPU ${index}`}</strong>
                                </h6>
                                <div class="row text-center">
                                    <div class="col-4">
                                        <div class="${usageClass}">
                                            <i class="fas fa-tachometer-alt"></i><br>
                                            <strong style="font-size: 18px;">${gpu.usage || 0}%</strong><br>
                                            <small class="text-muted">Zauzetost</small>
                                        </div>
                                    </div>
                                    <div class="col-4">
                                        <div class="${tempClass}">
                                            <i class="fas fa-thermometer-half"></i><br>
                                            <strong style="font-size: 18px;">${gpu.temp || 0}°C</strong><br>
                                            <small class="text-muted">Temperatura</small>
                                        </div>
                                    </div>
                                    <div class="col-4">
                                        <div class="${memClass}">
                                            <i class="fas fa-memory"></i><br>
                                            <strong style="font-size: 18px;">${gpu.memory || 0}%</strong><br>
                                            <small class="text-muted">Memorija</small>
                                        </div>
                                    </div>
                                </div>
                                ${gpu.fanSpeed ? `
                                <div class="mt-3 pt-2 border-top">
                                    <small style="color: #6c757d;">
                                        <i class="fas fa-fan fa-spin"></i> <strong>Fan: ${gpu.fanSpeed}%</strong> 
                                        ${gpu.powerDraw ? `| <i class="fas fa-bolt"></i> ${gpu.powerDraw}W` : ''}
                                    </small>
                                </div>
                                ` : ''}
                                ${gpu.processes && gpu.processes > 0 ? `
                                <div class="mt-2">
                                    <span class="badge bg-primary">
                                        <i class="fas fa-cogs"></i> ${gpu.processes} aktivnih procesa
                                    </span>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            gpuStatsContainer.innerHTML = gpuCardsHtml;
        }
        
        async function fetchServerConfig() {
            try {
                const response = await fetch('/api/config');
                const config = await response.json();
                serverConfig = config;
                console.log('Server config loaded:', serverConfig);
                
                // Load initial data now that config is available
                await fetchChannels();
                await fetchProfiles();
                await updateGPUMonitoring();
                
            } catch (error) {
                console.error('Error loading server config:', error);
                // Use default config if API fails
                serverConfig = {
                    streaming: { port: 3001 }
                };
                // Still try to load channels
                await fetchChannels();
                await fetchProfiles();
            }
        }

        // Initialize the application when document is loaded
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing application...');
            
            // Setup search functionality
            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    renderChannels();
                });
            }
            
            // Setup stop all button
            const stopAllBtn = document.getElementById('stop-all-btn');
            if (stopAllBtn) {
                stopAllBtn.addEventListener('click', stopAllStreams);
            }
            
            // Load server config first (contains port info)
            await fetchServerConfig();
            
            // Initial GPU stats load
            await updateGPUMonitoring();
            
            // Periodic updates
            setInterval(async () => {
                if (autoRefreshEnabled) {
                    await updateGPUMonitoring();
                }
            }, 10000); // Every 10 seconds for GPU stats
        });
    </script>
    </div> <!-- End main-content -->
</body>
</html>

